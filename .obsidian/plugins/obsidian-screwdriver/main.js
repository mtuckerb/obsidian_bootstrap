/*
THIS IS A GENERATED/BUNDLED FILE BY ESBUILD
if you want to view the source, please visit the github repository of this plugin
*/

var __create = Object.create;
var __defProp = Object.defineProperty;
var __getOwnPropDesc = Object.getOwnPropertyDescriptor;
var __getOwnPropNames = Object.getOwnPropertyNames;
var __getProtoOf = Object.getPrototypeOf;
var __hasOwnProp = Object.prototype.hasOwnProperty;
var __markAsModule = (target) => __defProp(target, "__esModule", { value: true });
var __export = (target, all) => {
  __markAsModule(target);
  for (var name in all)
    __defProp(target, name, { get: all[name], enumerable: true });
};
var __reExport = (target, module2, desc) => {
  if (module2 && typeof module2 === "object" || typeof module2 === "function") {
    for (let key of __getOwnPropNames(module2))
      if (!__hasOwnProp.call(target, key) && key !== "default")
        __defProp(target, key, { get: () => module2[key], enumerable: !(desc = __getOwnPropDesc(module2, key)) || desc.enumerable });
  }
  return target;
};
var __toModule = (module2) => {
  return __reExport(__markAsModule(__defProp(module2 != null ? __create(__getProtoOf(module2)) : {}, "default", module2 && module2.__esModule && "default" in module2 ? { get: () => module2.default, enumerable: true } : { value: module2, enumerable: true })), module2);
};
var __async = (__this, __arguments, generator) => {
  return new Promise((resolve, reject) => {
    var fulfilled = (value) => {
      try {
        step(generator.next(value));
      } catch (e) {
        reject(e);
      }
    };
    var rejected = (value) => {
      try {
        step(generator.throw(value));
      } catch (e) {
        reject(e);
      }
    };
    var step = (x) => x.done ? resolve(x.value) : Promise.resolve(x.value).then(fulfilled, rejected);
    step((generator = generator.apply(__this, __arguments)).next());
  });
};

// main.ts
__export(exports, {
  default: () => ScrewDriverPlugin
});
var import_obsidian = __toModule(require("obsidian"));
function getFiles(app, path, ignoreList, filter) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let files = [
      ...w.files.filter((e) => !ignoreList.some((ee) => e.endsWith(ee))).filter((e) => !filter || filter.some((ee) => e.match(ee)))
    ];
    L1:
      for (const v of w.folders) {
        for (const ignore of ignoreList) {
          if (v.endsWith(ignore)) {
            continue L1;
          }
        }
        files = files.concat(yield getFiles(app, v, ignoreList, filter));
      }
    return files;
  });
}
function getDirectories(app, path, ignoreList) {
  return __async(this, null, function* () {
    const w = yield app.vault.adapter.list(path);
    let dirs = [];
    L1:
      for (const v of w.folders) {
        for (const ignore of ignoreList) {
          if (v.endsWith(ignore)) {
            continue L1;
          }
        }
        dirs = dirs.concat([v]);
        dirs = dirs.concat(yield getDirectories(app, v, ignoreList));
      }
    return dirs;
  });
}
function isPlainText(filename) {
  if (filename.endsWith(".md"))
    return true;
  if (filename.endsWith(".txt"))
    return true;
  if (filename.endsWith(".svg"))
    return true;
  if (filename.endsWith(".html"))
    return true;
  if (filename.endsWith(".csv"))
    return true;
  if (filename.endsWith(".css"))
    return true;
  if (filename.endsWith(".js"))
    return true;
  if (filename.endsWith(".json"))
    return true;
  if (filename.endsWith(".xml"))
    return true;
  if (filename.endsWith(".ts"))
    return true;
  return false;
}
function arrayBufferToBase64(buffer) {
  return new Promise((res) => {
    const blob = new Blob([buffer], { type: "application/octet-binary" });
    const reader = new FileReader();
    reader.onload = function(evt) {
      const dataurl = evt.target.result.toString();
      res(dataurl.substr(dataurl.indexOf(",") + 1));
    };
    reader.readAsDataURL(blob);
  });
}
function base64ToArrayBuffer(base64) {
  try {
    const binary_string = window.atob(base64);
    const len = binary_string.length;
    const bytes = new Uint8Array(len);
    for (let i = 0; i < len; i++) {
      bytes[i] = binary_string.charCodeAt(i);
    }
    return bytes.buffer;
  } catch (ex) {
    try {
      return new Uint16Array([].map.call(base64, function(c) {
        return c.charCodeAt(0);
      })).buffer;
    } catch (ex2) {
      return null;
    }
  }
}
function ensureDirectory(app, fullpath) {
  return __async(this, null, function* () {
    const pathElements = fullpath.split("/");
    pathElements.pop();
    let c = "";
    for (const v of pathElements) {
      c += v;
      try {
        yield app.vault.createFolder(c);
      } catch (ex) {
        if (ex.message && ex.message == "Folder already exists.") {
        } else {
          new import_obsidian.Notice("Folder Create Error");
          console.log(ex);
        }
      }
      c += "/";
    }
  });
}
var ScrewDriverPlugin = class extends import_obsidian.Plugin {
  onload() {
    return __async(this, null, function* () {
      yield this.loadSettings();
      this.addCommand({
        id: "screwdriver-create-template",
        name: "Create dump template",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const data = view.data;
          if (data.trim() != "") {
            new import_obsidian.Notice("Please clear the note once. This plugin write the template to this file");
            return;
          }
          const list = yield getDirectories(this.app, this.app.vault.configDir, ["node_modules", ".git"]);
          const targets = list.map((e) => `# target: ${e}`).join("\n");
          editor.setValue(`---
# --- Select a directory to dump. ---
${targets}

# --- Prefixes to ignore. ---
ignores:
- /node_modules
- /.git

# --- Regular expressions for filtering files
filters:
# - \\.js
---

`);
        })
      });
      this.addCommand({
        id: "screwdriver-dump",
        name: "Dump files",
        editorCallback: (editor, view) => __async(this, null, function* () {
          var _a;
          const data = view.data;
          const bodyStartIndex = data.indexOf("\n---");
          if (!data.startsWith("---") || bodyStartIndex === -1) {
            new import_obsidian.Notice("Frontmatter was not found.");
          }
          const yaml = data.substring(3, bodyStartIndex);
          const yamlData = (0, import_obsidian.parseYaml)(yaml);
          let newData = "---" + yaml + "\n---\n\n";
          const target = (_a = yamlData.target) != null ? _a : "";
          const ignoresSrc = yamlData.ignores;
          const ignores = Array.isArray(ignoresSrc) ? ignoresSrc : (ignoresSrc + "").split(",");
          const filterSrc = yamlData.filters;
          const filters = !filterSrc ? null : filterSrc.map((e) => new RegExp(e));
          if (target.trim() == "") {
            new import_obsidian.Notice("Target folder not specified.");
            return;
          }
          const files = yield getFiles(this.app, target, ignores, filters);
          for (const file of files) {
            let fileDat = "";
            const stat = yield this.app.vault.adapter.stat(file);
            if (isPlainText(file)) {
              fileDat = yield this.app.vault.adapter.read(file);
              fileDat = fileDat.replace(/\\/g, "\\\\");
              fileDat = fileDat.replace(/`/g, "\\`");
            } else {
              const dtSrc = yield this.app.vault.adapter.readBinary(file);
              fileDat = yield arrayBufferToBase64(dtSrc);
            }
            newData += "\n";
            newData += `# ${file} 
`;
            newData += `- Created :${new Date(stat.ctime).toLocaleString()} 
`;
            newData += `- Modified:${new Date(stat.mtime).toLocaleString()} 
`;
            newData += "\n```" + file + "\n";
            newData += fileDat + "";
            newData += "\n```";
          }
          editor.setValue(newData);
        })
      });
      this.addCommand({
        id: "screwdriver-restore",
        name: "Restore files",
        editorCallback: (editor, view) => __async(this, null, function* () {
          const data = view.data;
          if (data.startsWith("---")) {
            const bodyStartIndex = data.indexOf("\n---");
            if (bodyStartIndex !== -1) {
              const preBlocks = data.substring(bodyStartIndex).matchAll(/^```([\s\S]*?)\n([\s\S]*?)^```/gm);
              for (const preBlock of preBlocks) {
                const [, filename, data2] = preBlock;
                let saveData = data2;
                try {
                  if (isPlainText(filename)) {
                    saveData = saveData.replace(/\\`/g, "`");
                    saveData = saveData.replace(/\\\\/g, "\\");
                    saveData = saveData.substring(0, saveData.lastIndexOf("\n"));
                    yield ensureDirectory(this.app, filename);
                    yield this.app.vault.adapter.write(filename, saveData);
                  } else {
                    const saveDataArrayBuffer = base64ToArrayBuffer(saveData);
                    yield ensureDirectory(this.app, filename);
                    yield this.app.vault.adapter.writeBinary(filename, saveDataArrayBuffer);
                  }
                  new import_obsidian.Notice(`File:${filename} has been wrote to your device.`);
                } catch (ex) {
                  new import_obsidian.Notice(`Failed to write ${filename}`);
                  console.log(ex);
                }
              }
              return;
            }
          }
          new import_obsidian.Notice("Frontmatter was not found.");
        })
      });
    });
  }
  onunload() {
  }
  loadSettings() {
    return __async(this, null, function* () {
    });
  }
  saveSettings() {
    return __async(this, null, function* () {
    });
  }
};
